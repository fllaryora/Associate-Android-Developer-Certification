/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.background;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.ViewModel;
import androidx.work.Constraints;
import androidx.work.Data;
import androidx.work.ExistingWorkPolicy;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkContinuation;
import androidx.work.WorkInfo;
import androidx.work.WorkManager;

import android.net.Uri;
import android.text.TextUtils;

import com.example.background.workers.BlurWorker;
import com.example.background.workers.CleanupWorker;
import com.example.background.workers.SaveImageToFileWorker;

import java.util.List;

import static com.example.background.Constants.IMAGE_MANIPULATION_WORK_NAME;
import static com.example.background.Constants.KEY_IMAGE_URI;
import static com.example.background.Constants.TAG_OUTPUT;

public class BlurViewModel extends ViewModel {

    private Uri mImageUri;
    private WorkManager mWorkManager;

    /** New instance variable for the WorkInfo
     * You can get the status of any WorkRequest by getting a LiveData that holds a WorkInfo object.
     * WorkInfo is an object that contains details about the current state of a WorkRequest, including:
     *
     * Whether the work is BLOCKED, CANCELLED, ENQUEUED, FAILED, RUNNING or SUCCEEDED
     * If the WorkRequest is finished, any output data from the work.
     * The following table shows three different ways to get LiveData<WorkInfo> or
     * LiveData<List<WorkInfo>> objects and what each does.
     *
     *
     Type: Get work using id

     WorkManager Method: getInfoByIdLiveData

     Description: Each WorkRequest has a unique ID generated by WorkManager;
     you can use this to get a single LiveData<WorkInfo> for that exact WorkRequest.

     Type: Get work using unique chain name

     WorkManager Method: getWorkInfosForUniqueWorkLiveData

     Description: As you've just seen, WorkRequests can be part of a unique chain.
     This returns LiveData<List<WorkInfo>> for all work in a single, unique chain of WorkRequests.


     Type: Get work using a tag

     WorkManager Method: getWorkInfosByTagLiveData

     Description: Finally, you can optionally tag any WorkRequest with a String.
     You can tag multiple WorkRequests with the same tag to associate them.
     This returns the LiveData<List<WorkInfo>> for any single tag.

     */
    private LiveData<List<WorkInfo>> mSavedWorkInfo;

    // New instance variable for the WorkInfo
    private Uri mOutputUri;

    public BlurViewModel() {
        mWorkManager = WorkManager.getInstance();

        mSavedWorkInfo = mWorkManager.getWorkInfosByTagLiveData(TAG_OUTPUT);
    }

    // Add a getter method for mSavedWorkInfo
    //monitored by activity
    LiveData<List<WorkInfo>> getOutputWorkInfo() { return mSavedWorkInfo; }

    /**
     * Create the WorkRequest to apply the blur and save the resulting image
     * @param blurLevel The amount to blur the image
     */
    void applyBlur(int blurLevel) {

    /**
     * WorkRequest: This represents a request to do some work.
     * You'll pass in your Worker as part of creating your WorkRequest.
     * When making the WorkRequest you can also specify things like
     * Constraints on when the Worker should run.
     */
        /**
         * UNIQUE SEQUESCE For example, if your app needs to sync its data to the network,
         * you might enqueue a sequence named "sync",
         * and specify that your new task should be ignored if there's already a sequence with that name.
         * Unique work sequences can also be useful if you need to gradually build up a long chain of tasks.
         * For example, a photo editing app might let users undo a long chain of actions.
         * Each of those undo operations might take a while, but they have to be performed in the correct order.
         * In this case, the app could create an "undo" chain and append each undo operation to the chain as needed.
         */
        // Add WorkRequest to Cleanup temporary images
        /**
         * Ensure that your chain of work to blur your file is unique by using beginUniqueWork.
         * Pass in IMAGE_MANIPULATION_WORK_NAME as the key.
         * You'll also need to pass in a ExistingWorkPolicy.
         * Your options are REPLACE, KEEP or APPEND.
         */
        WorkContinuation continuation = mWorkManager
                .beginUniqueWork(IMAGE_MANIPULATION_WORK_NAME,
                        /**
                         * You'll use REPLACE because if the user decides to blur
                         * another image before the current one is finished,
                         * we want to stop the current one and start blurring the new image.
                         * Blur-O-Matic will now only ever blur one picture at a time.
                         */
                        ExistingWorkPolicy.REPLACE,
                        OneTimeWorkRequest.from(CleanupWorker.class));

        // Add WorkRequests to blur the image the number of times requested
        for (int i = 0; i < blurLevel; i++) {
            OneTimeWorkRequest.Builder blurBuilder =
                    new OneTimeWorkRequest.Builder(BlurWorker.class);

            // Input the Uri if this is the first blur operation
            // After the first blur operation the input will be the output of previous
            // blur operations.
            if ( i == 0 ) {
                blurBuilder.setInputData(createInputDataForUri());
            }

            continuation = continuation.then(blurBuilder.build());
        }

        // Create charging constraint
        Constraints constraints = new Constraints.Builder()
                .setRequiresCharging(true)
                .build();

        // Add WorkRequest to save the image to the filesystem
        OneTimeWorkRequest save = new OneTimeWorkRequest.Builder(SaveImageToFileWorker.class)
                .setConstraints(constraints) // This adds the Constraints
                .addTag(TAG_OUTPUT) // This adds the tag
                .build();
        continuation = continuation.then(save);

        // Actually start the work
        continuation.enqueue();
    }

    private Uri uriOrNull(String uriString) {
        if (!TextUtils.isEmpty(uriString)) {
            return Uri.parse(uriString);
        }
        return null;
    }

    /**
     * Setters
     */
    void setImageUri(String uri) {
        mImageUri = uriOrNull(uri);
    }

    /**
     * Getters
     */
    Uri getImageUri() {
        return mImageUri;
    }

    /**
     * Creates the input data bundle which includes the Uri to operate on
     * @return Data which contains the Image Uri as a String
     *
     * Data objects are lightweight containers for key/value pairs.
     * They are meant to store a small amount of data
     * that might pass into and out from WorkRequests.
     *
     * You're going to pass in the URI for the user's image into a bundle.
     * That URI is stored in a variable called mImageUri.
     */
    private Data createInputDataForUri() {
        //1 Create a Data.Builder object.
        Data.Builder builder = new Data.Builder();
        //2 If mImageUri is a non-null URI,
        if (mImageUri != null) {
            // then add it to the Data object using the putString method.
            // This method takes a key and a value.
            // You can use the String constant KEY_IMAGE_URI from the Constants class.
            builder.putString(KEY_IMAGE_URI, mImageUri.toString());
        }
        //3 Call build() on the Data.Builder object to make your Data object, and return it.
        return builder.build();
    }

    // Add a getter and setter for mOutputUri
    void setOutputUri(String outputImageUri) {
        mOutputUri = uriOrNull(outputImageUri);
    }

    Uri getOutputUri() { return mOutputUri; }

    /**
     * Cancel work using the work's unique name
     */
    void cancelWork() {
        mWorkManager.cancelUniqueWork(IMAGE_MANIPULATION_WORK_NAME);
    }
}